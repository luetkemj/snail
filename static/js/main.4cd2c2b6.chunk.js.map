{"version":3,"sources":["lib/grid/math.js","constants/game.constants.js","lib/canvas.js","App.js","index.js"],"names":["getNeighbor","s","dir","row","col","topLeft","s1","s2","Math","min","bottomRight","max","cellToId","cell","idToCell","id","coords","split","parseInt","idToPoint","x","y","getRow","tlsq","brsq","push","keyBy","getColumn","column","getAllSquares","squares","each","getMaxColumn","map","getMinColumn","getMaxRow","getMinRow","getBoundary","ids","corners","topRight","bottomLeft","getBoundingCorners","boundarySquares","Object","keys","uniq","getPoint","COLUMNS","ROWS","MAP_HEIGHT","MAP_WIDTH","observeBoundaries","loc","getInitialCtx","canvasRef","ctx","current","getContext","font","textBaseline","drawPlayerHalo","player","cellIds","cells","localCells","radius","getAllSquaresFromPoint","localCellIds","localBoundaryCellIds","litCellIds","forEach","theLine","p0","p1","dx","dy","nx","abs","ny","sign_x","sign_y","p","points","ix","iy","walkGrid","_","point","cellId","pointToId","type","opacity","cellId1","cellId2","cell1","cell2","pow","floor","sqrt","getCellDistance","fillStyle","fillRect","drunkardsWalk","randomStart","dig","open","directions","sample","ceil","digger","nextCellId","times","drunkardsWalk2","categorizeCells","CELL_IDS","CELLS","FLOOR_CELL_IDS","WALL_CELL_IDS","neighbors","floors","length","isWall","PLAYER","find","renderGame","clearRect","debug","fillText","drawMap","drawPlayer","ReactDOM","render","useRef","useState","algorithm","iterations","startingLocation","randomStartingLocation","settings","setSettings","handleSettingChange","path","value","newSettings","useEffect","movePlayer","newLoc","newLocId","useEventListener","key","includes","String","className","htmlFor","name","onChange","e","target","checked","onClick","algorithms","dw","dw2","width","height","ref","document","getElementById"],"mappings":"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","file":"static/js/main.4cd2c2b6.chunk.js","sourcesContent":["import { each, keyBy, map, orderBy, uniq } from \"lodash\";\n\nexport const getCellDistance = (cellId1, cellId2) => {\n  const cell1 = idToCell(cellId1);\n  const cell2 = idToCell(cellId2);\n  const x = Math.pow(cell2.col - cell1.col, 2);\n  const y = Math.pow(cell2.row - cell1.row, 2);\n  return Math.floor(Math.sqrt(x + y));\n};\n\n// 00, 10, 20\n// 01, 11, 21\n// 02, 12, 22\n// dir\n// NW  N  NE\n// W       E\n// SW  S  SE\n// 01 col, row\n// { col: 0, row: 1 }\nexport const getNeighbor = (s, dir) => {\n  switch (dir) {\n    case \"N\":\n      return { ...s, row: s.row - 1 };\n    case \"NE\":\n      return { col: s.col + 1, row: s.row - 1 };\n    case \"E\":\n      return { ...s, col: s.col + 1 };\n    case \"SE\":\n      return { col: s.col + 1, row: s.row + 1 };\n    case \"S\":\n      return { ...s, row: s.row + 1 };\n    case \"SW\":\n      return { col: s.col - 1, row: s.row + 1 };\n    case \"W\":\n      return { ...s, col: s.col - 1 };\n    case \"NW\":\n      return { col: s.col - 1, row: s.row - 1 };\n\n    default:\n      return s;\n  }\n};\n\n// Given any 2 squares on a grid\n// return the top left square of their rectangle\n// ex: given 20 and 02 will return 00 from the square grid below\n// 00, 10, 20\n// 01, 11, 21\n// 02, 12, 22\nexport const topLeft = (s1, s2) => {\n  return {\n    col: Math.min(s1.col, s2.col),\n    row: Math.min(s1.row, s2.row)\n  };\n};\n\n// Given any 2 squares on a grid\n// return the bottom right square of their rectangle\n// ex: given 20 and 02 will return 22 from the square grid below\n// 00, 10, 20\n// 01, 11, 21\n// 02, 12, 22\nexport const bottomRight = (s1, s2) => {\n  return {\n    col: Math.max(s1.col, s2.col),\n    row: Math.max(s1.row, s2.row)\n  };\n};\n\nexport const cellToId = cell => `${cell.col},${cell.row}`;\nexport const pointToId = point => `${point.x},${point.y}`;\n\nexport const idToCell = id => {\n  const coords = id.split(\",\");\n  return { col: parseInt(coords[0], 10), row: parseInt(coords[1], 10) };\n};\n\nexport const idToPoint = id => {\n  const coords = id.split(\",\");\n  return { x: parseInt(coords[0], 10), y: parseInt(coords[1], 10) };\n};\n\n// Given two squares on a grid\n// return a horizontal L->R row from the top left sq of their rectangle\nexport const getRow = (s1, s2) => {\n  const tlsq = topLeft(s1, s2);\n  const brsq = bottomRight(s1, s2);\n  const row = [];\n\n  let col = tlsq.col;\n\n  while (col <= brsq.col) {\n    row.push({ col: col, row: tlsq.row });\n    col = col + 1;\n  }\n\n  return keyBy(row, cellToId);\n};\n\n// Given two squares on a grid\n// return a vertical T->B column from the top left sq of their rectangle\nexport const getColumn = (s1, s2) => {\n  const tlsq = topLeft(s1, s2);\n  const brsq = bottomRight(s1, s2);\n  const column = [];\n\n  let row = tlsq.row;\n\n  while (row <= brsq.row) {\n    column.push({ col: tlsq.col, row });\n    row = row + 1;\n  }\n\n  return keyBy(column, cellToId);\n};\n\n// given two squares on a grid, returns all squares within their rectangle\n// ex: given 10 and 02 will return the bracketed sqaures below\n//   [00], [10],  20\n//   [01], [11],  21\n//   [02], [12],  22\nexport const getAllSquares = (s1, s2) => {\n  const tlsq = topLeft(s1, s2);\n  const brsq = bottomRight(s1, s2);\n\n  let squares = {};\n\n  const column = getColumn(tlsq, brsq);\n\n  each(column, s => (squares = { ...squares, ...getRow(s, brsq) }));\n\n  return keyBy(squares, cellToId);\n};\n\nexport const getAllSquaresFromPoint = (s1, radius) => {\n  const topLeft = { col: s1.col - radius, row: s1.row - radius };\n  const bottomRight = { col: s1.col + radius, row: s1.row + radius };\n  return getAllSquares(topLeft, bottomRight);\n};\n\nexport const getMaxColumn = squares => {\n  return Math.max(...map(squares, s => s.col));\n};\n\nexport const getMinColumn = squares => {\n  return Math.min(...map(squares, s => s.col));\n};\n\nexport const getMaxRow = squares => {\n  return Math.max(...map(squares, s => s.row));\n};\n\nexport const getMinRow = squares => {\n  return Math.min(...map(squares, s => s.row));\n};\n\nexport const getBoundingCorners = squares => ({\n  topLeft: `${getMinColumn(squares)},${getMinRow(squares)}`,\n  topRight: `${getMaxColumn(squares)},${getMinRow(squares)}`,\n  bottomRight: `${getMaxColumn(squares)},${getMaxRow(squares)}`,\n  bottomLeft: `${getMinColumn(squares)},${getMaxRow(squares)}`\n});\n\nexport const getBoundary = ids => {\n  const squares = ids.map(idToCell);\n  const corners = getBoundingCorners(squares);\n  const boundarySquares = [\n    ...Object.keys(\n      getRow(idToCell(corners.topLeft), idToCell(corners.topRight))\n    ),\n    ...Object.keys(\n      getRow(idToCell(corners.bottomLeft), idToCell(corners.bottomRight))\n    ),\n    ...Object.keys(\n      getColumn(idToCell(corners.bottomLeft), idToCell(corners.topLeft))\n    ),\n    ...Object.keys(\n      getColumn(idToCell(corners.bottomRight), idToCell(corners.topRight))\n    )\n  ];\n  return uniq(boundarySquares);\n};\n\nexport const getPoint = (x, y) => ({ x, y });\n\nexport const diagonal_distance = (p0, p1) => {\n  var dx = p1.x - p0.x,\n    dy = p1.y - p0.y;\n  return Math.max(Math.abs(dx), Math.abs(dy));\n};\n\nexport const round_point = p => {\n  return getPoint(Math.round(p.x), Math.round(p.y));\n};\n\nexport const lerp_point = (p0, p1, t) => {\n  return getPoint(lerp(p0.x, p1.x, t), lerp(p0.y, p1.y, t));\n};\n\nexport const lerp = (start, end, t) => {\n  return start + t * (end - start);\n};\n\nexport const line = (p0, p1) => {\n  var points = [];\n  var N = diagonal_distance(p0, p1);\n  for (var step = 0; step <= N; step++) {\n    var t = N === 0 ? 0.0 : step / N;\n    points.push(round_point(lerp_point(p0, p1, t)));\n  }\n  return points;\n};\n\nexport const walkGrid = (p0, p1) => {\n  var dx = p1.x - p0.x,\n    dy = p1.y - p0.y;\n  var nx = Math.abs(dx),\n    ny = Math.abs(dy);\n  var sign_x = dx > 0 ? 1 : -1,\n    sign_y = dy > 0 ? 1 : -1;\n\n  var p = getPoint(p0.x, p0.y);\n  var points = [getPoint(p.x, p.y)];\n  for (var ix = 0, iy = 0; ix < nx || iy < ny; ) {\n    if ((0.5 + ix) / nx < (0.5 + iy) / ny) {\n      // next step is horizontal\n      p.x += sign_x;\n      ix++;\n    } else {\n      // next step is vertical\n      p.y += sign_y;\n      iy++;\n    }\n    points.push(getPoint(p.x, p.y));\n  }\n  return points;\n};\n","export const TILE_SIZE = 20;\nexport const CELL_WIDTH = TILE_SIZE;\nexport const CELL_HEIGHT = TILE_SIZE;\nexport const COLUMNS = 60;\nexport const ROWS = 40;\nexport const MAP_HEIGHT = CELL_HEIGHT * ROWS;\nexport const MAP_WIDTH = CELL_WIDTH * COLUMNS;\n","import _ from \"lodash\";\n\nimport {\n  // getAllSquares,\n  getBoundary,\n  getCellDistance,\n  getNeighbor,\n  cellToId,\n  idToCell,\n  idToPoint,\n  pointToId,\n  getAllSquaresFromPoint,\n  line,\n  walkGrid\n} from \"./grid/math\";\n\nimport {\n  TILE_SIZE,\n  CELL_WIDTH,\n  CELL_HEIGHT,\n  COLUMNS,\n  ROWS\n  // MAP_HEIGHT,\n  // MAP_WIDTH\n} from \"../constants/game.constants\";\n\nexport const observeBoundaries = id => {\n  const loc = idToCell(id);\n  if (loc.col < 0) return false;\n  if (loc.col >= COLUMNS) return false;\n  if (loc.row < 0) return false;\n  if (loc.row >= ROWS) return false;\n\n  return true;\n};\n\nexport const getInitialCtx = canvasRef => {\n  const ctx = canvasRef.current.getContext(\"2d\");\n  ctx.font = `${TILE_SIZE}px serif`;\n  ctx.textBaseline = \"top\";\n  return ctx;\n};\n\nexport const drawPlayer = (ctx, player) => {\n  ctx.fillStyle = `rgb(50,50,50,1)`;\n  ctx.fillText(\n    \"@\",\n    player.loc.col * CELL_WIDTH,\n    player.loc.row * CELL_HEIGHT,\n    CELL_WIDTH\n  );\n};\n\nexport const drawPlayerHalo = (ctx, player, cellIds, cells) => {\n  const localCells = getAllSquaresFromPoint(player.loc, 8);\n  const localCellIds = Object.keys(localCells);\n  const localBoundaryCellIds = getBoundary(localCellIds);\n  const litCellIds = [];\n\n  // console.log(localBoundaryCellIds);\n\n  localBoundaryCellIds.forEach(id => {\n    const start = { x: player.loc.col, y: player.loc.row };\n    const end = idToPoint(id);\n    const theLine = walkGrid(start, end);\n    // console.log({ start, end, theLine, player });\n\n    // iterate over theLine!!\n    _.each(theLine, point => {\n      const cellId = pointToId(point);\n      const cell = cells[cellId];\n\n      if (cell && cell.type && cell.type === \"floor\") {\n        litCellIds.push(cellId);\n      } else if (cell && cell.type && cell.type === \"wall\") {\n        litCellIds.push(cellId);\n        return false;\n      } else {\n        return false;\n      }\n    });\n    // from start if it's floor light\n    // it it's wall bail on all other cells\n    // cells[pointToId()]\n  });\n\n  // console.log({ litCellIds });\n\n  // from player location build halo of cell ids\n  // get distance on all cells in halo\n  // if they are open render light\n  _.uniq(litCellIds).forEach(cellId => {\n    const cell = cells[cellId];\n    if (cell) {\n      const opacity =\n        ((getCellDistance(cellToId(player.loc), cellId) - 8) * -1) / 7;\n      // ctx.fillStyle = `rgb(230,180,59,${opacity})`;\n      ctx.fillStyle = `rgb(255,255,255,${opacity})`;\n      // ctx.fillStyle = `rgb(255,0,0,${opacity})`;\n      ctx.fillRect(\n        cell.col * CELL_WIDTH,\n        cell.row * CELL_HEIGHT,\n        CELL_WIDTH,\n        CELL_HEIGHT\n      );\n\n      if (cell.type === \"wall\") {\n        // ctx.fillStyle = `rgb(60,85,92, ${opacity})`;\n        // ctx.fillStyle = `rgb(135,157,163, ${opacity})`;\n        ctx.fillStyle = `rgb(67, 82, 68, ${opacity})`;\n        // ctx.font = `${TILE_SIZE}px serif`;\n        // ctx.fillText(\"#\", cell.col * CELL_WIDTH, cell.row * CELL_HEIGHT);\n        ctx.fillRect(\n          cell.col * CELL_WIDTH,\n          cell.row * CELL_HEIGHT,\n          CELL_WIDTH,\n          CELL_HEIGHT\n        );\n      }\n    }\n  });\n};\n\n// cellIds ['id', ...]\n// cells { id: {col: 0, row: 0} }\n// player { loc: {col: 0, row: 0} }\n// debug boolean\nexport const drawMap = (ctx, cellIds, cells, player, debug = false) => {\n  cellIds.forEach(cellId => {\n    const cell = cells[cellId];\n\n    if (cell.type === \"floor\") ctx.fillStyle = `rgb(10,10,10)`;\n    else if (cell.type === \"wall\") ctx.fillStyle = `rgb(15,15,15)`;\n    else ctx.fillStyle = `rgb(12,12,12)`;\n    // ctx.fillStyle = cell.open ? `rgb(10,10,10)` : `rgb(15,15,15)`;\n    // ctx.fillStyle = cell.open ? `rgb(10,10,10)` : `rgb(11,11,11)`;\n    ctx.fillRect(\n      cell.col * CELL_WIDTH,\n      cell.row * CELL_HEIGHT,\n      CELL_WIDTH,\n      CELL_HEIGHT\n    );\n\n    // testing\n    // if (cell.type === \"floor\") {\n    //   ctx.fillStyle = `rgb(255,255,255, 1)`;\n    //   ctx.font = `${TILE_SIZE}px serif`;\n    //   ctx.fillText(\"â˜\", cell.col * CELL_WIDTH, cell.row * CELL_HEIGHT);\n    // }\n\n    // if (cell.type === \"wall\") {\n    //   ctx.fillStyle = `rgb(255,255,255, 1)`;\n    //   ctx.font = `${TILE_SIZE}px serif`;\n    //   ctx.fillText(\"#\", cell.col * CELL_WIDTH, cell.row * CELL_HEIGHT);\n    // }\n\n    if (debug) {\n      ctx.fillStyle = `rgb(200,0,0, 1)`;\n      ctx.font = \"8px serif\";\n      ctx.fillText(cellId, cell.col * CELL_WIDTH, cell.row * CELL_HEIGHT);\n    }\n  });\n};\n\nexport const drunkardsWalk = (cellIds, cells, randomStart = false) => {\n  const dig = cell => (cell.open = true);\n  const directions = [\"N\", \"E\", \"S\", \"W\"];\n\n  // Pick start location\n  let current = randomStart\n    ? _.sample(cellIds)\n    : `${Math.ceil(COLUMNS / 2)},${Math.ceil(ROWS / 2)}`;\n\n  dig(cells[current]);\n\n  const digger = () => {\n    // get the next cell Id\n    const nextCellId = cellToId(\n      getNeighbor(cells[current], _.sample(directions))\n    );\n\n    // test that it is in bounds\n    if (observeBoundaries(nextCellId)) {\n      if (!cells[nextCellId].open) {\n        dig(cells[nextCellId]);\n        current = nextCellId;\n      }\n    }\n  };\n\n  _.times(2500, digger);\n};\n\nexport const drunkardsWalk2 = (cellIds, cells, randomStart = false) => {\n  const dig = cell => (cell.open = true);\n  const directions = [\"N\", \"E\", \"S\", \"W\"];\n\n  // Pick start location\n  let current = randomStart\n    ? _.sample(cellIds)\n    : `${Math.ceil(COLUMNS / 2)},${Math.ceil(ROWS / 2)}`;\n\n  dig(cells[current]);\n\n  const digger = () => {\n    // get the next cell Id\n    const nextCellId = cellToId(\n      getNeighbor(cells[current], _.sample(directions))\n    );\n\n    // test that it is in bounds\n    if (observeBoundaries(nextCellId)) {\n      dig(cells[nextCellId]);\n      current = nextCellId;\n    }\n  };\n\n  _.times(1500, digger);\n};\n\nexport const isWall = (CELLS, cellId) => {\n  const point = idToPoint(cellId);\n  const neighbors = [\n    `${point.x},${point.y - 1}`, // N\n    `${point.x + 1},${point.y}`, // E\n    `${point.x},${point.y + 1}`, // S\n    `${point.x - 1},${point.y}` // W\n  ];\n\n  const floors = [];\n  neighbors.forEach(id => {\n    const cell = CELLS[id];\n    if (cell && cell.type === \"floor\") {\n      floors.push(id);\n    }\n  });\n\n  if (floors.length > 0) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const categorizeCells = (CELL_IDS, CELLS) => {\n  const FLOOR_CELL_IDS = [];\n  const WALL_CELL_IDS = [];\n  const ROCK_CELL_IDS = [];\n\n  // mark floors\n  CELL_IDS.forEach(id => {\n    const cell = CELLS[id];\n    if (cell.open) {\n      cell.type = \"floor\";\n      FLOOR_CELL_IDS.push(id);\n      return;\n    }\n  });\n\n  CELL_IDS.forEach(id => {\n    const cell = CELLS[id];\n    if (!cell.type && isWall(CELLS, id)) {\n      // console.log(\"WALL!\");\n      cell.type = \"wall\";\n      WALL_CELL_IDS.push(id);\n      return;\n    }\n  });\n};\n","import React, { useEffect, useRef, useState } from \"react\";\nimport useEventListener from \"@use-it/event-listener\";\nimport { cellToId, getAllSquares, getNeighbor } from \"./lib/grid/math\";\nimport { observeBoundaries, drawPlayerHalo } from \"./lib/canvas\";\nimport _ from \"lodash\";\n\nimport \"./App.css\";\n\nimport {\n  COLUMNS,\n  ROWS,\n  MAP_HEIGHT,\n  MAP_WIDTH\n} from \"./constants/game.constants\";\n\nimport {\n  drawMap,\n  drawPlayer,\n  getInitialCtx,\n  drunkardsWalk,\n  drunkardsWalk2,\n  categorizeCells\n} from \"./lib/canvas\";\n\nlet CELLS = getAllSquares(\n  { col: 0, row: 0, open: false },\n  { col: COLUMNS, row: ROWS }\n);\nconst CELL_IDS = Object.keys(CELLS);\n\ndrunkardsWalk2(CELL_IDS, CELLS);\ncategorizeCells(CELL_IDS, CELLS);\n\nlet PLAYER = {\n  loc: _.find(CELLS, cell => cell.open)\n};\n\nlet ctx;\n\nconst renderGame = ctx => {\n  ctx.clearRect(0, 0, MAP_WIDTH, MAP_HEIGHT);\n  drawMap(ctx, CELL_IDS, CELLS, PLAYER);\n  drawPlayerHalo(ctx, PLAYER, CELL_IDS, CELLS);\n  drawPlayer(ctx, PLAYER);\n};\n\nexport default function App() {\n  const canvasRef = useRef(null);\n  const [settings, setSettings] = useState({\n    algorithm: \"dw\",\n    iterations: 30,\n    startingLocation: \"30,20\",\n    randomStartingLocation: \"on\"\n  });\n\n  const rebuild = () => {\n    CELLS = getAllSquares(\n      { col: 0, row: 0, open: false },\n      { col: COLUMNS, row: ROWS }\n    );\n\n    const algorithms = {\n      dw: drunkardsWalk,\n      dw2: drunkardsWalk2\n    };\n\n    _.times(settings.iterations, () =>\n      algorithms[settings.algorithm](\n        CELL_IDS,\n        CELLS,\n        settings.randomStartingLocation === \"on\"\n      )\n    );\n\n    categorizeCells(CELL_IDS, CELLS);\n\n    PLAYER = {\n      loc: _.find(CELLS, cell => cell.open)\n    };\n\n    renderGame(ctx);\n  };\n\n  const handleSettingChange = (path, value) => {\n    const newSettings = { ...settings };\n    newSettings[path] = value;\n    setSettings(newSettings);\n  };\n\n  useEffect(() => {\n    ctx = getInitialCtx(canvasRef);\n    renderGame(ctx);\n  });\n\n  const movePlayer = dir => {\n    const newLoc = getNeighbor(PLAYER.loc, dir);\n    const newLocId = cellToId(newLoc);\n    if (!observeBoundaries(newLocId)) return;\n    if (!CELLS[newLocId].open) return;\n\n    PLAYER.loc = newLoc;\n\n    renderGame(ctx);\n  };\n\n  const handleKeyDown = ({ key }) => {\n    // key bindings\n    const PLAYER_MOVE_N = [\"ArrowUp\", \"8\", \"w\"];\n    const PLAYER_MOVE_E = [\"ArrowRight\", \"6\", \"d\"];\n    const PLAYER_MOVE_S = [\"ArrowDown\", \"2\", \"s\"];\n    const PLAYER_MOVE_W = [\"ArrowLeft\", \"4\", \"a\"];\n\n    if (PLAYER_MOVE_N.includes(String(key))) {\n      movePlayer(\"N\");\n    }\n\n    if (PLAYER_MOVE_E.includes(String(key))) {\n      movePlayer(\"E\");\n    }\n\n    if (PLAYER_MOVE_S.includes(String(key))) {\n      movePlayer(\"S\");\n    }\n\n    if (PLAYER_MOVE_W.includes(String(key))) {\n      movePlayer(\"W\");\n    }\n  };\n\n  useEventListener(\"keydown\", handleKeyDown);\n\n  return (\n    <div className=\"App\">\n      <div className=\"settings\">\n        SETTINGS:\n        <label htmlFor=\"Algorithm\">Algorithm:</label>\n        <select\n          name=\"Algorithm\"\n          value={settings.algorithm}\n          onChange={e => {\n            handleSettingChange(\"algorithm\", e.target.value);\n          }}\n        >\n          <option value=\"dw\">Drunkards Walk</option>\n          <option value=\"dw2\">Drunkards Walk 2</option>\n        </select>\n        <label htmlFor=\"iterations\">Iterations:</label>\n        <input\n          name=\"iterations\"\n          type=\"number\"\n          min=\"1\"\n          max=\"1000\"\n          value={settings.iterations}\n          onChange={e => {\n            handleSettingChange(\"iterations\", e.target.value);\n          }}\n        />\n        {/* <label htmlFor=\"startLocation\">Starting Location:</label>\n        <input\n          type=\"text\"\n          name=\"startLocation\"\n          value={settings.startingLocation}\n          onChange={e => {\n            handleSettingChange(\"startingLocation\", e.target.value);\n          }}\n        /> */}\n        <label htmlFor=\"randomStart\">Random Starting Location</label>\n        <input\n          type=\"checkbox\"\n          name=\"randomStart\"\n          checked={settings.randomStartingLocation}\n          onChange={e => {\n            handleSettingChange(\n              \"randomStartingLocation\",\n              settings.randomStartingLocation === \"on\" ? \"\" : \"on\"\n            );\n          }}\n        />\n        <button onClick={rebuild}>Rebuild Map</button>\n      </div>\n      <canvas\n        width={MAP_WIDTH}\n        height={MAP_HEIGHT}\n        className=\"canvas\"\n        ref={canvasRef}\n      />\n    </div>\n  );\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}