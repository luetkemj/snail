{"version":3,"sources":["lib/grid/math.js","constants/game.constants.js","lib/canvas.js","App.js","index.js"],"names":["getNeighbor","s","dir","col","row","topLeft","s1","s2","Math","min","bottomRight","max","cellToId","cell","idToCell","id","coords","split","parseInt","idToPoint","x","y","getRow","tlsq","brsq","push","keyBy","getColumn","column","getAllSquares","squares","each","getMaxColumn","map","getMinColumn","getMaxRow","getMinRow","getBoundary","ids","corners","topRight","bottomLeft","getBoundingCorners","boundarySquares","Object","keys","uniq","getPoint","COLUMNS","ROWS","MAP_HEIGHT","MAP_WIDTH","observeBoundaries","loc","getInitialCtx","canvasRef","ctx","current","getContext","font","textBaseline","drawPlayerHalo","player","cellIds","cells","localCells","radius","getAllSquaresFromPoint","localCellIds","localBoundaryCellIds","litCellIds","forEach","theLine","p0","p1","dx","dy","nx","abs","ny","sign_x","sign_y","p","points","ix","iy","walkGrid","_","point","cellId","pointToId","type","opacity","cellId1","cellId2","cell1","cell2","pow","floor","sqrt","getCellDistance","fillStyle","fillRect","drunkardsWalk","randomStart","dig","open","directions","sample","ceil","digger","nextCellId","times","drunkardsWalk2","categorizeCells","CELL_IDS","CELLS","FLOOR_CELL_IDS","WALL_CELL_IDS","neighbors","floors","length","isWall","dijkstra","start","startId","frontier","distance","shift","neighborId","PLAYER","find","renderGame","settings","clearRect","debug","fillText","drawMap","drawPlayer","goal","dMap","c","drawDijkstraMap","ReactDOM","render","useRef","useState","algorithm","iterations","startingLocation","randomStartingLocation","setSettings","handleSettingChange","path","value","newSettings","useEffect","movePlayer","newLoc","newLocId","useEventListener","key","includes","String","className","htmlFor","name","onChange","e","target","checked","onClick","algorithms","dw","dw2","width","height","ref","document","getElementById"],"mappings":"scAEO,IAiBMA,EAAc,SAACC,EAAGC,GAC7B,OAAQA,GACN,IAAK,IACH,MAAO,CAAEC,IAAKF,EAAEE,IAAKC,IAAKH,EAAEG,IAAM,GACpC,IAAK,KACH,MAAO,CAAED,IAAKF,EAAEE,IAAM,EAAGC,IAAKH,EAAEG,IAAM,GACxC,IAAK,IACH,MAAO,CAAEA,IAAKH,EAAEG,IAAKD,IAAKF,EAAEE,IAAM,GACpC,IAAK,KACH,MAAO,CAAEA,IAAKF,EAAEE,IAAM,EAAGC,IAAKH,EAAEG,IAAM,GACxC,IAAK,IACH,MAAO,CAAED,IAAKF,EAAEE,IAAKC,IAAKH,EAAEG,IAAM,GACpC,IAAK,KACH,MAAO,CAAED,IAAKF,EAAEE,IAAM,EAAGC,IAAKH,EAAEG,IAAM,GACxC,IAAK,IACH,MAAO,CAAEA,IAAKH,EAAEG,IAAKD,IAAKF,EAAEE,IAAM,GACpC,IAAK,KACH,MAAO,CAAEA,IAAKF,EAAEE,IAAM,EAAGC,IAAKH,EAAEG,IAAM,GAExC,QACE,OAAOH,IAUAI,EAAU,SAACC,EAAIC,GAC1B,MAAO,CACLJ,IAAKK,KAAKC,IAAIH,EAAGH,IAAKI,EAAGJ,KACzBC,IAAKI,KAAKC,IAAIH,EAAGF,IAAKG,EAAGH,OAUhBM,EAAc,SAACJ,EAAIC,GAC9B,MAAO,CACLJ,IAAKK,KAAKG,IAAIL,EAAGH,IAAKI,EAAGJ,KACzBC,IAAKI,KAAKG,IAAIL,EAAGF,IAAKG,EAAGH,OAIhBQ,EAAW,SAAAC,GAAI,gBAAOA,EAAKV,IAAZ,YAAmBU,EAAKT,MAGvCU,EAAW,SAAAC,GACtB,IAAMC,EAASD,EAAGE,MAAM,KACxB,MAAO,CAAEd,IAAKe,SAASF,EAAO,GAAI,IAAKZ,IAAKc,SAASF,EAAO,GAAI,MAGrDG,EAAY,SAAAJ,GACvB,IAAMC,EAASD,EAAGE,MAAM,KACxB,MAAO,CAAEG,EAAGF,SAASF,EAAO,GAAI,IAAKK,EAAGH,SAASF,EAAO,GAAI,MAKjDM,EAAS,SAAChB,EAAIC,GAOzB,IANA,IAAMgB,EAAOlB,EAAQC,EAAIC,GACnBiB,EAAOd,EAAYJ,EAAIC,GACvBH,EAAM,GAERD,EAAMoB,EAAKpB,IAERA,GAAOqB,EAAKrB,KACjBC,EAAIqB,KAAK,CAAEtB,IAAKA,EAAKC,IAAKmB,EAAKnB,MAC/BD,GAAY,EAGd,OAAOuB,gBAAMtB,EAAKQ,IAKPe,EAAY,SAACrB,EAAIC,GAO5B,IANA,IAAMgB,EAAOlB,EAAQC,EAAIC,GACnBiB,EAAOd,EAAYJ,EAAIC,GACvBqB,EAAS,GAEXxB,EAAMmB,EAAKnB,IAERA,GAAOoB,EAAKpB,KACjBwB,EAAOH,KAAK,CAAEtB,IAAKoB,EAAKpB,IAAKC,QAC7BA,GAAY,EAGd,OAAOsB,gBAAME,EAAQhB,IAQViB,EAAgB,SAACvB,EAAIC,GAChC,IAAMgB,EAAOlB,EAAQC,EAAIC,GACnBiB,EAAOd,EAAYJ,EAAIC,GAEzBuB,EAAU,GAERF,EAASD,EAAUJ,EAAMC,GAI/B,OAFAO,eAAKH,GAAQ,SAAA3B,GAAC,OAAK6B,E,yVAAO,IAAQA,EAAR,GAAoBR,EAAOrB,EAAGuB,OAEjDE,gBAAMI,EAASlB,IASXoB,EAAe,SAAAF,GAC1B,OAAOtB,KAAKG,IAAL,MAAAH,KAAI,YAAQyB,cAAIH,GAAS,SAAA7B,GAAC,OAAIA,EAAEE,UAG5B+B,EAAe,SAAAJ,GAC1B,OAAOtB,KAAKC,IAAL,MAAAD,KAAI,YAAQyB,cAAIH,GAAS,SAAA7B,GAAC,OAAIA,EAAEE,UAG5BgC,EAAY,SAAAL,GACvB,OAAOtB,KAAKG,IAAL,MAAAH,KAAI,YAAQyB,cAAIH,GAAS,SAAA7B,GAAC,OAAIA,EAAEG,UAG5BgC,EAAY,SAAAN,GACvB,OAAOtB,KAAKC,IAAL,MAAAD,KAAI,YAAQyB,cAAIH,GAAS,SAAA7B,GAAC,OAAIA,EAAEG,UAU5BiC,EAAc,SAAAC,GACzB,IACMC,EAT0B,SAAAT,GAAO,MAAK,CAC5CzB,QAAQ,GAAD,OAAK6B,EAAaJ,GAAlB,YAA8BM,EAAUN,IAC/CU,SAAS,GAAD,OAAKR,EAAaF,GAAlB,YAA8BM,EAAUN,IAChDpB,YAAY,GAAD,OAAKsB,EAAaF,GAAlB,YAA8BK,EAAUL,IACnDW,WAAW,GAAD,OAAKP,EAAaJ,GAAlB,YAA8BK,EAAUL,KAKlCY,CADAJ,EAAIL,IAAInB,IAElB6B,EAAe,sBAChBC,OAAOC,KACRvB,EAAOR,EAASyB,EAAQlC,SAAUS,EAASyB,EAAQC,aAFlC,YAIhBI,OAAOC,KACRvB,EAAOR,EAASyB,EAAQE,YAAa3B,EAASyB,EAAQ7B,gBALrC,YAOhBkC,OAAOC,KACRlB,EAAUb,EAASyB,EAAQE,YAAa3B,EAASyB,EAAQlC,YARxC,YAUhBuC,OAAOC,KACRlB,EAAUb,EAASyB,EAAQ7B,aAAcI,EAASyB,EAAQC,cAG9D,OAAOM,eAAKH,IAGDI,EAAW,SAAC3B,EAAGC,GAAJ,MAAW,CAAED,IAAGC,MCpL3B2B,EAAU,GACVC,EAAO,GACPC,EALY,GAKeD,EAC3BE,EANY,GAMaH,ECoBzBI,EAAoB,SAAArC,GAC/B,IAAMsC,EAAMvC,EAASC,GACrB,QAAIsC,EAAIlD,IAAM,OACVkD,EAAIlD,KAAO6C,OACXK,EAAIjD,IAAM,MACViD,EAAIjD,KAAO6C,MAKJK,EAAgB,SAAAC,GAC3B,IAAMC,EAAMD,EAAUE,QAAQC,WAAW,MAGzC,OAFAF,EAAIG,KAAJ,UDtCuB,GCsCvB,YACAH,EAAII,aAAe,MACZJ,GAcIK,EAAiB,SAACL,EAAKM,EAAQC,EAASC,GACnD,IAAMC,EF+E8B,SAAC3D,EAAI4D,GACzC,IAAM7D,EAAU,CAAEF,IAAKG,EAAGH,IAAM+D,EAAQ9D,IAAKE,EAAGF,IAAM8D,GAChDxD,EAAc,CAAEP,IAAKG,EAAGH,IAAM+D,EAAQ9D,IAAKE,EAAGF,IAAM8D,GAC1D,OAAOrC,EAAcxB,EAASK,GElFXyD,CAAuBL,EAAOT,IAAK,GAChDe,EAAexB,OAAOC,KAAKoB,GAC3BI,EAAuBhC,EAAY+B,GACnCE,EAAa,GAEnBD,EAAqBE,SAAQ,SAAAxD,GAC3B,IAEMyD,EFsJc,SAACC,EAAIC,GAU3B,IATA,IAAIC,EAAKD,EAAGtD,EAAIqD,EAAGrD,EACjBwD,EAAKF,EAAGrD,EAAIoD,EAAGpD,EACbwD,EAAKrE,KAAKsE,IAAIH,GAChBI,EAAKvE,KAAKsE,IAAIF,GACZI,EAASL,EAAK,EAAI,GAAK,EACzBM,EAASL,EAAK,EAAI,GAAK,EAErBM,EAAInC,EAAS0B,EAAGrD,EAAGqD,EAAGpD,GACtB8D,EAAS,CAACpC,EAASmC,EAAE9D,EAAG8D,EAAE7D,IACrB+D,EAAK,EAAGC,EAAK,EAAGD,EAAKP,GAAMQ,EAAKN,IAClC,GAAMK,GAAMP,GAAM,GAAMQ,GAAMN,GAEjCG,EAAE9D,GAAK4D,EACPI,MAGAF,EAAE7D,GAAK4D,EACPI,KAEFF,EAAO1D,KAAKsB,EAASmC,EAAE9D,EAAG8D,EAAE7D,IAE9B,OAAO8D,EE5KWG,CAFF,CAAElE,EAAG0C,EAAOT,IAAIlD,IAAKkB,EAAGyC,EAAOT,IAAIjD,KACrCe,EAAUJ,IAItBwE,IAAExD,KAAKyC,GAAS,SAAAgB,GACd,IAAMC,EFGa,SAAAD,GAAK,gBAAOA,EAAMpE,EAAb,YAAkBoE,EAAMnE,GEHjCqE,CAAUF,GACnB3E,EAAOmD,EAAMyB,GAEnB,IAAI5E,IAAQA,EAAK8E,MAAsB,UAAd9E,EAAK8E,KAEvB,SAAI9E,IAAQA,EAAK8E,MAAsB,SAAd9E,EAAK8E,QACnCrB,EAAW7C,KAAKgE,IACT,GAHPnB,EAAW7C,KAAKgE,SAatBF,IAAEzC,KAAKwB,GAAYC,SAAQ,SAAAkB,GACzB,IAAM5E,EAAOmD,EAAMyB,GACnB,GAAI5E,EAAM,CACR,IAAM+E,GACoD,GFtFjC,SAACC,EAASC,GACvC,IAAMC,EAAQjF,EAAS+E,GACjBG,EAAQlF,EAASgF,GACjB1E,EAAIZ,KAAKyF,IAAID,EAAM7F,IAAM4F,EAAM5F,IAAK,GACpCkB,EAAIb,KAAKyF,IAAID,EAAM5F,IAAM2F,EAAM3F,IAAK,GAC1C,OAAOI,KAAK0F,MAAM1F,KAAK2F,KAAK/E,EAAIC,IEiFxB+E,CAAgBxF,EAASkD,EAAOT,KAAMoC,GAAU,GAAW,EAC/DjC,EAAI6C,UAAJ,0BAAmCT,EAAnC,KACApC,EAAI8C,SD1Fe,GC2FjBzF,EAAKV,ID3FY,GC4FjBU,EAAKT,ID5FY,OCiGD,SAAdS,EAAK8E,OACPnC,EAAI6C,UAAJ,0BAAmCT,EAAnC,KACApC,EAAI8C,SDnGa,GCoGfzF,EAAKV,IDpGU,GCqGfU,EAAKT,IDrGU,aCyKZmG,EAAgB,SAACxC,EAASC,GAAgC,IAAzBwC,EAAwB,wDAC9DC,EAAM,SAAA5F,GAAI,OAAKA,EAAK6F,MAAO,GAC3BC,EAAa,CAAC,IAAK,IAAK,IAAK,KAG/BlD,EAAU+C,EACVjB,IAAEqB,OAAO7C,GADY,UAElBvD,KAAKqG,KAAK7D,EAAU,GAFF,YAEQxC,KAAKqG,KAAK5D,EAAO,IAElDwD,EAAIzC,EAAMP,IAEV,IAAMqD,EAAS,WAEb,IAAMC,EAAanG,EACjBZ,EAAYgE,EAAMP,GAAU8B,IAAEqB,OAAOD,KAInCvD,EAAkB2D,KACf/C,EAAM+C,GAAYL,OACrBD,EAAIzC,EAAM+C,IACVtD,EAAUsD,KAKhBxB,IAAEyB,MAAM,KAAMF,IAGHG,EAAiB,SAAClD,EAASC,GAAgC,IAAzBwC,EAAwB,wDAC/DC,EAAM,SAAA5F,GAAI,OAAKA,EAAK6F,MAAO,GAC3BC,EAAa,CAAC,IAAK,IAAK,IAAK,KAG/BlD,EAAU+C,EACVjB,IAAEqB,OAAO7C,GADY,UAElBvD,KAAKqG,KAAK7D,EAAU,GAFF,YAEQxC,KAAKqG,KAAK5D,EAAO,IAElDwD,EAAIzC,EAAMP,IAEV,IAAMqD,EAAS,WAEb,IAAMC,EAAanG,EACjBZ,EAAYgE,EAAMP,GAAU8B,IAAEqB,OAAOD,KAInCvD,EAAkB2D,KACpBN,EAAIzC,EAAM+C,IACVtD,EAAUsD,IAIdxB,IAAEyB,MAAM,KAAMF,IA2BHI,EAAkB,SAACC,EAAUC,GACxC,IAAMC,EAAiB,GACjBC,EAAgB,GAItBH,EAAS5C,SAAQ,SAAAxD,GACf,IAAMF,EAAOuG,EAAMrG,GACnB,GAAIF,EAAK6F,KAGP,OAFA7F,EAAK8E,KAAO,aACZ0B,EAAe5F,KAAKV,MAKxBoG,EAAS5C,SAAQ,SAAAxD,GACf,IAAMF,EAAOuG,EAAMrG,GACnB,IAAKF,EAAK8E,MAzCQ,SAACyB,EAAO3B,GAC5B,IAAMD,EAAQrE,EAAUsE,GAClB8B,EAAY,CAAC,GAAD,OACb/B,EAAMpE,EADO,YACFoE,EAAMnE,EAAI,GADR,UAEbmE,EAAMpE,EAAI,EAFG,YAEEoE,EAAMnE,GAFR,UAGbmE,EAAMpE,EAHO,YAGFoE,EAAMnE,EAAI,GAHR,UAIbmE,EAAMpE,EAAI,EAJG,YAIEoE,EAAMnE,IAGpBmG,EAAS,GAQf,OAPAD,EAAUhD,SAAQ,SAAAxD,GAChB,IAAMF,EAAOuG,EAAMrG,GACfF,GAAsB,UAAdA,EAAK8E,MACf6B,EAAO/F,KAAKV,MAIZyG,EAAOC,OAAS,EAwBAC,CAAON,EAAOrG,GAG9B,OAFAF,EAAK8E,KAAO,YACZ2B,EAAc7F,KAAKV,OAMnB4G,EAAW,SAACC,EAAO5D,GAMvB,IALA,IACM6D,EAAUjH,EADEgH,GAEZE,EAAW,CAACD,GACZE,EAAQ,eAAMF,EAAU,GAJG,aAO/B,IAAMpE,EAAUqE,EAASE,QACP,CAChBpH,EAASZ,EAAYc,EAAS2C,GAAU,MACxC7C,EAASZ,EAAYc,EAAS2C,GAAU,MACxC7C,EAASZ,EAAYc,EAAS2C,GAAU,MACxC7C,EAASZ,EAAYc,EAAS2C,GAAU,OAEhCc,SAAQ,SAAA0D,GAEXF,EAASE,IACRjE,EAAMiE,IAA0C,UAA3BjE,EAAMiE,GAAYtC,OACzCoC,EAASE,GAAcF,EAAStE,GAAW,EAC3CqE,EAASrG,KAAKwG,QAbfH,EAASL,QAAS,IAoBzB,OADAM,EAASF,GAAW,EACbE,G,oOCnRT,IAAIX,EAAQvF,EACV,CAAE1B,IAAK,EAAGC,IAAK,EAAGsG,MAAM,GACxB,CAAEvG,IAAK6C,EAAS5C,IAAK6C,IAEjBkE,EAAWvE,OAAOC,KAAKuE,GAE7BH,EAAeE,EAAUC,GACzBF,EAAgBC,EAAUC,GAE1B,IAII5D,EAJA0E,EAAS,CACX7E,IAAKkC,IAAE4C,KAAKf,GAAO,SAAAvG,GAAI,OAAIA,EAAK6F,SAK5B0B,EAAa,SAAC5E,EAAK6E,GACvB7E,EAAI8E,UAAU,EAAG,EAAGnF,EAAWD,GDyEV,SAACM,EAAKO,EAASC,EAAOF,GAA2B,IAAnByE,EAAkB,wDACrExE,EAAQQ,SAAQ,SAAAkB,GACd,IAAM5E,EAAOmD,EAAMyB,GAED,UAAd5E,EAAK8E,KAAkBnC,EAAI6C,UAAJ,gBACJ,SAAdxF,EAAK8E,KAAiBnC,EAAI6C,UAAJ,gBAC1B7C,EAAI6C,UAAJ,gBACL7C,EAAI8C,SDzHiB,GC0HnBzF,EAAKV,ID1Hc,GC2HnBU,EAAKT,ID3Hc,OC6IjBmI,IACF/E,EAAI6C,UAAJ,kBACA7C,EAAIG,KAAO,YACXH,EAAIgF,SAAS/C,EDhJM,GCgJE5E,EAAKV,IDhJP,GCgJyBU,EAAKT,SCtGrDqI,CAAQjF,EAAK2D,EAAUC,EAAOc,GAC9BrE,EAAeL,EAAK0E,EAAQf,EAAUC,GDAd,SAAC5D,EAAKM,GAC9BN,EAAI6C,UAAJ,kBACA7C,EAAIG,KAAJ,UD7CuB,GC6CvB,YACAH,EAAIgF,SACF,ID/CqB,GCgDrB1E,EAAOT,IAAIlD,IDhDU,GCiDrB2D,EAAOT,IAAIjD,IDjDU,IE4CvBsI,CAAWlF,EAAK0E,GACU,OAAtBG,EAASV,UDkHgB,SAACnE,EAAKmF,EAAM3E,GACzC,IAAM4E,EAAOjB,EAASgB,EAAM3E,GAC5BpB,OAAOC,KAAK+F,GAAMrE,SAAQ,SAAAxD,GACxB,IAAM8H,EAAI/H,EAASC,GACnByC,EAAI6C,UAAJ,kBACA7C,EAAIG,KAAO,aACXH,EAAIgF,SAASI,EAAK7H,GDrKG,GCqKE8H,EAAE1I,IDrKJ,GCqKsB0I,EAAEzI,QCvH7C0I,CAAgBtF,EAAK0E,EAAO7E,IAAK+D,ICzCrC2B,IAASC,OAAO,mBD6CD,WACb,IAAMzF,EAAY0F,iBAAO,MADG,EAEIC,mBAAS,CACvCC,UAAW,KACXC,WAAY,GACZC,iBAAkB,QAClBC,uBAAwB,OANE,mBAErBjB,EAFqB,KAEXkB,EAFW,KAqCtBC,EAAsB,SAACC,EAAMC,GACjC,IAAMC,E,yVAAW,IAAQtB,GACzBsB,EAAYF,GAAQC,EACpBH,EAAYI,IAGdC,qBAAU,WACRpG,EAAMF,EAAcC,GACpB6E,EAAW5E,EAAK6E,MAGlB,IAAMwB,EAAa,SAAA3J,GACjB,IAAM4J,EAAS9J,EAAYkI,EAAO7E,IAAKnD,GACjC6J,EAAWnJ,EAASkJ,GACrB1G,EAAkB2G,IAClB3C,EAAM2C,GAAUrD,OAErBwB,EAAO7E,IAAMyG,EAEb1B,EAAW5E,EAAK6E,KA6BlB,OAFA2B,YAAiB,WAxBK,SAAC,GAAa,IAAXC,EAAU,EAAVA,IAED,CAAC,UAAW,IAAK,KAKrBC,SAASC,OAAOF,KAChCJ,EAAW,KALS,CAAC,aAAc,IAAK,KAQxBK,SAASC,OAAOF,KAChCJ,EAAW,KARS,CAAC,YAAa,IAAK,KAWvBK,SAASC,OAAOF,KAChCJ,EAAW,KAXS,CAAC,YAAa,IAAK,KAcvBK,SAASC,OAAOF,KAChCJ,EAAW,QAOb,yBAAKO,UAAU,OACb,yBAAKA,UAAU,YAAf,YAEE,2BAAOC,QAAQ,aAAf,cACA,4BACEC,KAAK,YACLZ,MAAOrB,EAASc,UAChBoB,SAAU,SAAAC,GACRhB,EAAoB,YAAagB,EAAEC,OAAOf,SAG5C,4BAAQA,MAAM,MAAd,kBACA,4BAAQA,MAAM,OAAd,qBAEF,2BAAOW,QAAQ,cAAf,eACA,2BACEC,KAAK,aACL3E,KAAK,SACLlF,IAAI,IACJE,IAAI,OACJ+I,MAAOrB,EAASe,WAChBmB,SAAU,SAAAC,GACRhB,EAAoB,aAAcgB,EAAEC,OAAOf,UAG/C,2BAAOW,QAAQ,eAAf,4BACA,2BACE1E,KAAK,WACL2E,KAAK,cACLI,QAASrC,EAASiB,uBAClBiB,SAAU,SAAAC,GACRhB,EACE,yBACoC,OAApCnB,EAASiB,uBAAkC,GAAK,SAItD,2BAAOe,QAAQ,eAAf,gBACA,2BACE1E,KAAK,WACL2E,KAAK,WACLI,QAASrC,EAASV,SAClB4C,SAAU,SAAAC,GACRhB,EACE,WACsB,OAAtBnB,EAASV,SAAoB,GAAK,SAIxC,4BAAQgD,QA9HE,WACdvD,EAAQvF,EACN,CAAE1B,IAAK,EAAGC,IAAK,EAAGsG,MAAM,GACxB,CAAEvG,IAAK6C,EAAS5C,IAAK6C,IAGvB,IAAM2H,EAAa,CACjBC,GAAItE,EACJuE,IAAK7D,GAGP1B,IAAEyB,MAAMqB,EAASe,YAAY,kBAC3BwB,EAAWvC,EAASc,WAClBhC,EACAC,EACoC,OAApCiB,EAASiB,2BAIbpC,EAAgBC,EAAUC,GAE1Bc,EAAS,CACP7E,IAAKkC,IAAE4C,KAAKf,GAAO,SAAAvG,GAAI,OAAIA,EAAK6F,SAGlC0B,EAAW5E,EAAK6E,KAqGZ,gBAEF,4BACE0C,MAAO5H,EACP6H,OAAQ9H,EACRkH,UAAU,SACVa,IAAK1H,OC1LG,MAAS2H,SAASC,eAAe,U","file":"static/js/main.a7946d2b.chunk.js","sourcesContent":["import { each, keyBy, map, orderBy, uniq } from \"lodash\";\n\nexport const getCellDistance = (cellId1, cellId2) => {\n  const cell1 = idToCell(cellId1);\n  const cell2 = idToCell(cellId2);\n  const x = Math.pow(cell2.col - cell1.col, 2);\n  const y = Math.pow(cell2.row - cell1.row, 2);\n  return Math.floor(Math.sqrt(x + y));\n};\n\n// 00, 10, 20\n// 01, 11, 21\n// 02, 12, 22\n// dir\n// NW  N  NE\n// W       E\n// SW  S  SE\n// 01 col, row\n// { col: 0, row: 1 }\nexport const getNeighbor = (s, dir) => {\n  switch (dir) {\n    case \"N\":\n      return { col: s.col, row: s.row - 1 };\n    case \"NE\":\n      return { col: s.col + 1, row: s.row - 1 };\n    case \"E\":\n      return { row: s.row, col: s.col + 1 };\n    case \"SE\":\n      return { col: s.col + 1, row: s.row + 1 };\n    case \"S\":\n      return { col: s.col, row: s.row + 1 };\n    case \"SW\":\n      return { col: s.col - 1, row: s.row + 1 };\n    case \"W\":\n      return { row: s.row, col: s.col - 1 };\n    case \"NW\":\n      return { col: s.col - 1, row: s.row - 1 };\n\n    default:\n      return s;\n  }\n};\n\n// Given any 2 squares on a grid\n// return the top left square of their rectangle\n// ex: given 20 and 02 will return 00 from the square grid below\n// 00, 10, 20\n// 01, 11, 21\n// 02, 12, 22\nexport const topLeft = (s1, s2) => {\n  return {\n    col: Math.min(s1.col, s2.col),\n    row: Math.min(s1.row, s2.row)\n  };\n};\n\n// Given any 2 squares on a grid\n// return the bottom right square of their rectangle\n// ex: given 20 and 02 will return 22 from the square grid below\n// 00, 10, 20\n// 01, 11, 21\n// 02, 12, 22\nexport const bottomRight = (s1, s2) => {\n  return {\n    col: Math.max(s1.col, s2.col),\n    row: Math.max(s1.row, s2.row)\n  };\n};\n\nexport const cellToId = cell => `${cell.col},${cell.row}`;\nexport const pointToId = point => `${point.x},${point.y}`;\n\nexport const idToCell = id => {\n  const coords = id.split(\",\");\n  return { col: parseInt(coords[0], 10), row: parseInt(coords[1], 10) };\n};\n\nexport const idToPoint = id => {\n  const coords = id.split(\",\");\n  return { x: parseInt(coords[0], 10), y: parseInt(coords[1], 10) };\n};\n\n// Given two squares on a grid\n// return a horizontal L->R row from the top left sq of their rectangle\nexport const getRow = (s1, s2) => {\n  const tlsq = topLeft(s1, s2);\n  const brsq = bottomRight(s1, s2);\n  const row = [];\n\n  let col = tlsq.col;\n\n  while (col <= brsq.col) {\n    row.push({ col: col, row: tlsq.row });\n    col = col + 1;\n  }\n\n  return keyBy(row, cellToId);\n};\n\n// Given two squares on a grid\n// return a vertical T->B column from the top left sq of their rectangle\nexport const getColumn = (s1, s2) => {\n  const tlsq = topLeft(s1, s2);\n  const brsq = bottomRight(s1, s2);\n  const column = [];\n\n  let row = tlsq.row;\n\n  while (row <= brsq.row) {\n    column.push({ col: tlsq.col, row });\n    row = row + 1;\n  }\n\n  return keyBy(column, cellToId);\n};\n\n// given two squares on a grid, returns all squares within their rectangle\n// ex: given 10 and 02 will return the bracketed sqaures below\n//   [00], [10],  20\n//   [01], [11],  21\n//   [02], [12],  22\nexport const getAllSquares = (s1, s2) => {\n  const tlsq = topLeft(s1, s2);\n  const brsq = bottomRight(s1, s2);\n\n  let squares = {};\n\n  const column = getColumn(tlsq, brsq);\n\n  each(column, s => (squares = { ...squares, ...getRow(s, brsq) }));\n\n  return keyBy(squares, cellToId);\n};\n\nexport const getAllSquaresFromPoint = (s1, radius) => {\n  const topLeft = { col: s1.col - radius, row: s1.row - radius };\n  const bottomRight = { col: s1.col + radius, row: s1.row + radius };\n  return getAllSquares(topLeft, bottomRight);\n};\n\nexport const getMaxColumn = squares => {\n  return Math.max(...map(squares, s => s.col));\n};\n\nexport const getMinColumn = squares => {\n  return Math.min(...map(squares, s => s.col));\n};\n\nexport const getMaxRow = squares => {\n  return Math.max(...map(squares, s => s.row));\n};\n\nexport const getMinRow = squares => {\n  return Math.min(...map(squares, s => s.row));\n};\n\nexport const getBoundingCorners = squares => ({\n  topLeft: `${getMinColumn(squares)},${getMinRow(squares)}`,\n  topRight: `${getMaxColumn(squares)},${getMinRow(squares)}`,\n  bottomRight: `${getMaxColumn(squares)},${getMaxRow(squares)}`,\n  bottomLeft: `${getMinColumn(squares)},${getMaxRow(squares)}`\n});\n\nexport const getBoundary = ids => {\n  const squares = ids.map(idToCell);\n  const corners = getBoundingCorners(squares);\n  const boundarySquares = [\n    ...Object.keys(\n      getRow(idToCell(corners.topLeft), idToCell(corners.topRight))\n    ),\n    ...Object.keys(\n      getRow(idToCell(corners.bottomLeft), idToCell(corners.bottomRight))\n    ),\n    ...Object.keys(\n      getColumn(idToCell(corners.bottomLeft), idToCell(corners.topLeft))\n    ),\n    ...Object.keys(\n      getColumn(idToCell(corners.bottomRight), idToCell(corners.topRight))\n    )\n  ];\n  return uniq(boundarySquares);\n};\n\nexport const getPoint = (x, y) => ({ x, y });\n\nexport const diagonal_distance = (p0, p1) => {\n  var dx = p1.x - p0.x,\n    dy = p1.y - p0.y;\n  return Math.max(Math.abs(dx), Math.abs(dy));\n};\n\nexport const round_point = p => {\n  return getPoint(Math.round(p.x), Math.round(p.y));\n};\n\nexport const lerp_point = (p0, p1, t) => {\n  return getPoint(lerp(p0.x, p1.x, t), lerp(p0.y, p1.y, t));\n};\n\nexport const lerp = (start, end, t) => {\n  return start + t * (end - start);\n};\n\nexport const line = (p0, p1) => {\n  var points = [];\n  var N = diagonal_distance(p0, p1);\n  for (var step = 0; step <= N; step++) {\n    var t = N === 0 ? 0.0 : step / N;\n    points.push(round_point(lerp_point(p0, p1, t)));\n  }\n  return points;\n};\n\nexport const walkGrid = (p0, p1) => {\n  var dx = p1.x - p0.x,\n    dy = p1.y - p0.y;\n  var nx = Math.abs(dx),\n    ny = Math.abs(dy);\n  var sign_x = dx > 0 ? 1 : -1,\n    sign_y = dy > 0 ? 1 : -1;\n\n  var p = getPoint(p0.x, p0.y);\n  var points = [getPoint(p.x, p.y)];\n  for (var ix = 0, iy = 0; ix < nx || iy < ny; ) {\n    if ((0.5 + ix) / nx < (0.5 + iy) / ny) {\n      // next step is horizontal\n      p.x += sign_x;\n      ix++;\n    } else {\n      // next step is vertical\n      p.y += sign_y;\n      iy++;\n    }\n    points.push(getPoint(p.x, p.y));\n  }\n  return points;\n};\n","export const TILE_SIZE = 20;\nexport const CELL_WIDTH = TILE_SIZE;\nexport const CELL_HEIGHT = TILE_SIZE;\nexport const COLUMNS = 60;\nexport const ROWS = 40;\nexport const MAP_HEIGHT = CELL_HEIGHT * ROWS;\nexport const MAP_WIDTH = CELL_WIDTH * COLUMNS;\n","import _ from \"lodash\";\n\nimport {\n  // getAllSquares,\n  getBoundary,\n  getCellDistance,\n  getNeighbor,\n  cellToId,\n  idToCell,\n  idToPoint,\n  pointToId,\n  getAllSquaresFromPoint,\n  line,\n  walkGrid\n} from \"./grid/math\";\n\nimport {\n  TILE_SIZE,\n  CELL_WIDTH,\n  CELL_HEIGHT,\n  COLUMNS,\n  ROWS\n  // MAP_HEIGHT,\n  // MAP_WIDTH\n} from \"../constants/game.constants\";\n\nexport const observeBoundaries = id => {\n  const loc = idToCell(id);\n  if (loc.col < 0) return false;\n  if (loc.col >= COLUMNS) return false;\n  if (loc.row < 0) return false;\n  if (loc.row >= ROWS) return false;\n\n  return true;\n};\n\nexport const getInitialCtx = canvasRef => {\n  const ctx = canvasRef.current.getContext(\"2d\");\n  ctx.font = `${TILE_SIZE}px serif`;\n  ctx.textBaseline = \"top\";\n  return ctx;\n};\n\nexport const drawPlayer = (ctx, player) => {\n  ctx.fillStyle = `rgb(50,50,50,1)`;\n  ctx.font = `${TILE_SIZE}px serif`;\n  ctx.fillText(\n    \"@\",\n    player.loc.col * CELL_WIDTH,\n    player.loc.row * CELL_HEIGHT,\n    CELL_WIDTH\n  );\n};\n\nexport const drawPlayerHalo = (ctx, player, cellIds, cells) => {\n  const localCells = getAllSquaresFromPoint(player.loc, 8);\n  const localCellIds = Object.keys(localCells);\n  const localBoundaryCellIds = getBoundary(localCellIds);\n  const litCellIds = [];\n\n  localBoundaryCellIds.forEach(id => {\n    const start = { x: player.loc.col, y: player.loc.row };\n    const end = idToPoint(id);\n    const theLine = walkGrid(start, end);\n\n    // iterate over theLine!!\n    _.each(theLine, point => {\n      const cellId = pointToId(point);\n      const cell = cells[cellId];\n\n      if (cell && cell.type && cell.type === \"floor\") {\n        litCellIds.push(cellId);\n      } else if (cell && cell.type && cell.type === \"wall\") {\n        litCellIds.push(cellId);\n        return false;\n      } else {\n        return false;\n      }\n    });\n  });\n\n  // from player location build halo of cell ids\n  // get distance on all cells in halo\n  // if they are open render light\n  _.uniq(litCellIds).forEach(cellId => {\n    const cell = cells[cellId];\n    if (cell) {\n      const opacity =\n        ((getCellDistance(cellToId(player.loc), cellId) - 8) * -1) / 7;\n      ctx.fillStyle = `rgb(255,255,255,${opacity})`;\n      ctx.fillRect(\n        cell.col * CELL_WIDTH,\n        cell.row * CELL_HEIGHT,\n        CELL_WIDTH,\n        CELL_HEIGHT\n      );\n\n      if (cell.type === \"wall\") {\n        ctx.fillStyle = `rgb(67, 82, 68, ${opacity})`;\n        ctx.fillRect(\n          cell.col * CELL_WIDTH,\n          cell.row * CELL_HEIGHT,\n          CELL_WIDTH,\n          CELL_HEIGHT\n        );\n      }\n    }\n  });\n};\n\n// cellIds ['id', ...]\n// cells { id: {col: 0, row: 0} }\n// player { loc: {col: 0, row: 0} }\n// debug boolean\nexport const drawMap = (ctx, cellIds, cells, player, debug = false) => {\n  cellIds.forEach(cellId => {\n    const cell = cells[cellId];\n\n    if (cell.type === \"floor\") ctx.fillStyle = `rgb(10,10,10)`;\n    else if (cell.type === \"wall\") ctx.fillStyle = `rgb(15,15,15)`;\n    else ctx.fillStyle = `rgb(12,12,12)`;\n    ctx.fillRect(\n      cell.col * CELL_WIDTH,\n      cell.row * CELL_HEIGHT,\n      CELL_WIDTH,\n      CELL_HEIGHT\n    );\n\n    // testing\n    // if (cell.type === \"floor\") {\n    //   ctx.fillStyle = `rgb(255,255,255, 1)`;\n    //   ctx.font = `${TILE_SIZE}px serif`;\n    //   ctx.fillText(\"☐\", cell.col * CELL_WIDTH, cell.row * CELL_HEIGHT);\n    // }\n\n    // if (cell.type === \"wall\") {\n    //   ctx.fillStyle = `rgb(255,255,255, 1)`;\n    //   ctx.font = `${TILE_SIZE}px serif`;\n    //   ctx.fillText(\"#\", cell.col * CELL_WIDTH, cell.row * CELL_HEIGHT);\n    // }\n\n    if (debug) {\n      ctx.fillStyle = `rgb(200,0,0, 1)`;\n      ctx.font = \"8px serif\";\n      ctx.fillText(cellId, cell.col * CELL_WIDTH, cell.row * CELL_HEIGHT);\n    }\n  });\n\n  // const dMap = dijkstra(player.loc, cells);\n\n  // Object.keys(dMap).forEach(id => {\n  //   const c = idToCell(id);\n\n  //   ctx.fillStyle = `rgb(200,0,0, 1)`;\n  //   ctx.font = \"12px serif\";\n  //   ctx.fillText(dMap[id], c.col * CELL_WIDTH, c.row * CELL_HEIGHT);\n  // });\n};\n\nexport const drawDijkstraMap = (ctx, goal, cells) => {\n  const dMap = dijkstra(goal, cells);\n  Object.keys(dMap).forEach(id => {\n    const c = idToCell(id);\n    ctx.fillStyle = `rgb(200,0,0, 1)`;\n    ctx.font = \"12px serif\";\n    ctx.fillText(dMap[id], c.col * CELL_WIDTH, c.row * CELL_HEIGHT);\n  });\n};\n\nexport const drunkardsWalk = (cellIds, cells, randomStart = false) => {\n  const dig = cell => (cell.open = true);\n  const directions = [\"N\", \"E\", \"S\", \"W\"];\n\n  // Pick start location\n  let current = randomStart\n    ? _.sample(cellIds)\n    : `${Math.ceil(COLUMNS / 2)},${Math.ceil(ROWS / 2)}`;\n\n  dig(cells[current]);\n\n  const digger = () => {\n    // get the next cell Id\n    const nextCellId = cellToId(\n      getNeighbor(cells[current], _.sample(directions))\n    );\n\n    // test that it is in bounds\n    if (observeBoundaries(nextCellId)) {\n      if (!cells[nextCellId].open) {\n        dig(cells[nextCellId]);\n        current = nextCellId;\n      }\n    }\n  };\n\n  _.times(2500, digger);\n};\n\nexport const drunkardsWalk2 = (cellIds, cells, randomStart = false) => {\n  const dig = cell => (cell.open = true);\n  const directions = [\"N\", \"E\", \"S\", \"W\"];\n\n  // Pick start location\n  let current = randomStart\n    ? _.sample(cellIds)\n    : `${Math.ceil(COLUMNS / 2)},${Math.ceil(ROWS / 2)}`;\n\n  dig(cells[current]);\n\n  const digger = () => {\n    // get the next cell Id\n    const nextCellId = cellToId(\n      getNeighbor(cells[current], _.sample(directions))\n    );\n\n    // test that it is in bounds\n    if (observeBoundaries(nextCellId)) {\n      dig(cells[nextCellId]);\n      current = nextCellId;\n    }\n  };\n\n  _.times(1500, digger);\n};\n\nexport const isWall = (CELLS, cellId) => {\n  const point = idToPoint(cellId);\n  const neighbors = [\n    `${point.x},${point.y - 1}`, // N\n    `${point.x + 1},${point.y}`, // E\n    `${point.x},${point.y + 1}`, // S\n    `${point.x - 1},${point.y}` // W\n  ];\n\n  const floors = [];\n  neighbors.forEach(id => {\n    const cell = CELLS[id];\n    if (cell && cell.type === \"floor\") {\n      floors.push(id);\n    }\n  });\n\n  if (floors.length > 0) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const categorizeCells = (CELL_IDS, CELLS) => {\n  const FLOOR_CELL_IDS = [];\n  const WALL_CELL_IDS = [];\n  const ROCK_CELL_IDS = [];\n\n  // mark floors\n  CELL_IDS.forEach(id => {\n    const cell = CELLS[id];\n    if (cell.open) {\n      cell.type = \"floor\";\n      FLOOR_CELL_IDS.push(id);\n      return;\n    }\n  });\n\n  CELL_IDS.forEach(id => {\n    const cell = CELLS[id];\n    if (!cell.type && isWall(CELLS, id)) {\n      cell.type = \"wall\";\n      WALL_CELL_IDS.push(id);\n      return;\n    }\n  });\n};\n\nconst dijkstra = (start, cells) => {\n  const startCell = start;\n  const startId = cellToId(startCell);\n  const frontier = [startId];\n  const distance = { [startId]: 0 };\n\n  while (frontier.length) {\n    const current = frontier.shift();\n    const neighbors = [\n      cellToId(getNeighbor(idToCell(current), \"N\")),\n      cellToId(getNeighbor(idToCell(current), \"E\")),\n      cellToId(getNeighbor(idToCell(current), \"S\")),\n      cellToId(getNeighbor(idToCell(current), \"W\"))\n    ];\n    neighbors.forEach(neighborId => {\n      // const neighborCellId = cellToId(neighbor);\n      if (!distance[neighborId]) {\n        if (cells[neighborId] && cells[neighborId].type === \"floor\") {\n          distance[neighborId] = distance[current] + 1;\n          frontier.push(neighborId);\n        }\n      }\n    });\n  }\n\n  distance[startId] = 0;\n  return distance;\n};\n","import React, { useEffect, useRef, useState } from \"react\";\nimport useEventListener from \"@use-it/event-listener\";\nimport { cellToId, getAllSquares, getNeighbor } from \"./lib/grid/math\";\nimport { observeBoundaries, drawPlayerHalo } from \"./lib/canvas\";\nimport _ from \"lodash\";\n\nimport \"./App.css\";\n\nimport {\n  COLUMNS,\n  ROWS,\n  MAP_HEIGHT,\n  MAP_WIDTH\n} from \"./constants/game.constants\";\n\nimport {\n  drawMap,\n  drawPlayer,\n  drawDijkstraMap,\n  getInitialCtx,\n  drunkardsWalk,\n  drunkardsWalk2,\n  categorizeCells\n} from \"./lib/canvas\";\n\nlet CELLS = getAllSquares(\n  { col: 0, row: 0, open: false },\n  { col: COLUMNS, row: ROWS }\n);\nconst CELL_IDS = Object.keys(CELLS);\n\ndrunkardsWalk2(CELL_IDS, CELLS);\ncategorizeCells(CELL_IDS, CELLS);\n\nlet PLAYER = {\n  loc: _.find(CELLS, cell => cell.open)\n};\n\nlet ctx;\n\nconst renderGame = (ctx, settings) => {\n  ctx.clearRect(0, 0, MAP_WIDTH, MAP_HEIGHT);\n  drawMap(ctx, CELL_IDS, CELLS, PLAYER);\n  drawPlayerHalo(ctx, PLAYER, CELL_IDS, CELLS);\n  drawPlayer(ctx, PLAYER);\n  if (settings.dijkstra === \"on\") {\n    drawDijkstraMap(ctx, PLAYER.loc, CELLS);\n  }\n};\n\nexport default function App() {\n  const canvasRef = useRef(null);\n  const [settings, setSettings] = useState({\n    algorithm: \"dw\",\n    iterations: 30,\n    startingLocation: \"30,20\",\n    randomStartingLocation: \"on\"\n  });\n\n  const rebuild = () => {\n    CELLS = getAllSquares(\n      { col: 0, row: 0, open: false },\n      { col: COLUMNS, row: ROWS }\n    );\n\n    const algorithms = {\n      dw: drunkardsWalk,\n      dw2: drunkardsWalk2\n    };\n\n    _.times(settings.iterations, () =>\n      algorithms[settings.algorithm](\n        CELL_IDS,\n        CELLS,\n        settings.randomStartingLocation === \"on\"\n      )\n    );\n\n    categorizeCells(CELL_IDS, CELLS);\n\n    PLAYER = {\n      loc: _.find(CELLS, cell => cell.open)\n    };\n\n    renderGame(ctx, settings);\n  };\n\n  const handleSettingChange = (path, value) => {\n    const newSettings = { ...settings };\n    newSettings[path] = value;\n    setSettings(newSettings);\n  };\n\n  useEffect(() => {\n    ctx = getInitialCtx(canvasRef);\n    renderGame(ctx, settings);\n  });\n\n  const movePlayer = dir => {\n    const newLoc = getNeighbor(PLAYER.loc, dir);\n    const newLocId = cellToId(newLoc);\n    if (!observeBoundaries(newLocId)) return;\n    if (!CELLS[newLocId].open) return;\n\n    PLAYER.loc = newLoc;\n\n    renderGame(ctx, settings);\n  };\n\n  const handleKeyDown = ({ key }) => {\n    // key bindings\n    const PLAYER_MOVE_N = [\"ArrowUp\", \"8\", \"w\"];\n    const PLAYER_MOVE_E = [\"ArrowRight\", \"6\", \"d\"];\n    const PLAYER_MOVE_S = [\"ArrowDown\", \"2\", \"s\"];\n    const PLAYER_MOVE_W = [\"ArrowLeft\", \"4\", \"a\"];\n\n    if (PLAYER_MOVE_N.includes(String(key))) {\n      movePlayer(\"N\");\n    }\n\n    if (PLAYER_MOVE_E.includes(String(key))) {\n      movePlayer(\"E\");\n    }\n\n    if (PLAYER_MOVE_S.includes(String(key))) {\n      movePlayer(\"S\");\n    }\n\n    if (PLAYER_MOVE_W.includes(String(key))) {\n      movePlayer(\"W\");\n    }\n  };\n\n  useEventListener(\"keydown\", handleKeyDown);\n\n  return (\n    <div className=\"App\">\n      <div className=\"settings\">\n        SETTINGS:\n        <label htmlFor=\"Algorithm\">Algorithm:</label>\n        <select\n          name=\"Algorithm\"\n          value={settings.algorithm}\n          onChange={e => {\n            handleSettingChange(\"algorithm\", e.target.value);\n          }}\n        >\n          <option value=\"dw\">Drunkards Walk</option>\n          <option value=\"dw2\">Drunkards Walk 2</option>\n        </select>\n        <label htmlFor=\"iterations\">Iterations:</label>\n        <input\n          name=\"iterations\"\n          type=\"number\"\n          min=\"1\"\n          max=\"1000\"\n          value={settings.iterations}\n          onChange={e => {\n            handleSettingChange(\"iterations\", e.target.value);\n          }}\n        />\n        <label htmlFor=\"randomStart\">Random Starting Location</label>\n        <input\n          type=\"checkbox\"\n          name=\"randomStart\"\n          checked={settings.randomStartingLocation}\n          onChange={e => {\n            handleSettingChange(\n              \"randomStartingLocation\",\n              settings.randomStartingLocation === \"on\" ? \"\" : \"on\"\n            );\n          }}\n        />\n        <label htmlFor=\"randomStart\">Dijkstra Map</label>\n        <input\n          type=\"checkbox\"\n          name=\"dijkstra\"\n          checked={settings.dijkstra}\n          onChange={e => {\n            handleSettingChange(\n              \"dijkstra\",\n              settings.dijkstra === \"on\" ? \"\" : \"on\"\n            );\n          }}\n        />\n        <button onClick={rebuild}>Rebuild Map</button>\n      </div>\n      <canvas\n        width={MAP_WIDTH}\n        height={MAP_HEIGHT}\n        className=\"canvas\"\n        ref={canvasRef}\n      />\n    </div>\n  );\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}