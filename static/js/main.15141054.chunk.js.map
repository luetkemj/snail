{"version":3,"sources":["lib/grid/math.js","constants/game.constants.js","lib/canvas.js","App.js","index.js"],"names":["getNeighbor","s","dir","row","col","topLeft","s1","s2","Math","min","bottomRight","max","cellToId","cell","idToCell","id","coords","split","parseInt","idToPoint","x","y","getRow","tlsq","brsq","push","keyBy","getColumn","column","getAllSquares","squares","each","getMaxColumn","map","getMinColumn","getMaxRow","getMinRow","getBoundary","ids","corners","topRight","bottomLeft","getBoundingCorners","boundarySquares","Object","keys","uniq","getPoint","lerp_point","p0","p1","t","lerp","start","end","line","p","points","N","dx","dy","abs","diagonal_distance","step","round","COLUMNS","ROWS","MAP_HEIGHT","MAP_WIDTH","observeBoundaries","loc","getInitialCtx","canvasRef","ctx","current","getContext","font","textBaseline","drawPlayerHalo","player","cellIds","cells","localCells","radius","getAllSquaresFromPoint","localCellIds","localBoundaryCellIds","litCellIds","forEach","theLine","_","point","cellId","pointToId","type","opacity","cellId1","cellId2","cell1","cell2","pow","floor","sqrt","getCellDistance","fillStyle","fillRect","drunkardsWalk","randomStart","dig","open","directions","sample","ceil","digger","nextCellId","times","drunkardsWalk2","categorizeCells","CELL_IDS","CELLS","FLOOR_CELL_IDS","WALL_CELL_IDS","neighbors","floors","length","isWall","PLAYER","find","renderGame","clearRect","debug","fillText","drawMap","drawPlayer","ReactDOM","render","useRef","useState","algorithm","iterations","startingLocation","randomStartingLocation","settings","setSettings","handleSettingChange","path","value","newSettings","useEffect","movePlayer","newLoc","newLocId","useEventListener","key","includes","String","className","htmlFor","name","onChange","e","target","checked","onClick","algorithms","dw","dw2","width","height","ref","document","getElementById"],"mappings":"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","file":"static/js/main.15141054.chunk.js","sourcesContent":["import { each, keyBy, map, orderBy, uniq } from \"lodash\";\n\nexport const getCellDistance = (cellId1, cellId2) => {\n  const cell1 = idToCell(cellId1);\n  const cell2 = idToCell(cellId2);\n  const x = Math.pow(cell2.col - cell1.col, 2);\n  const y = Math.pow(cell2.row - cell1.row, 2);\n  return Math.floor(Math.sqrt(x + y));\n};\n\n// 00, 10, 20\n// 01, 11, 21\n// 02, 12, 22\n// dir\n// NW  N  NE\n// W       E\n// SW  S  SE\n// 01 col, row\n// { col: 0, row: 1 }\nexport const getNeighbor = (s, dir) => {\n  switch (dir) {\n    case \"N\":\n      return { ...s, row: s.row - 1 };\n    case \"NE\":\n      return { col: s.col + 1, row: s.row - 1 };\n    case \"E\":\n      return { ...s, col: s.col + 1 };\n    case \"SE\":\n      return { col: s.col + 1, row: s.row + 1 };\n    case \"S\":\n      return { ...s, row: s.row + 1 };\n    case \"SW\":\n      return { col: s.col - 1, row: s.row + 1 };\n    case \"W\":\n      return { ...s, col: s.col - 1 };\n    case \"NW\":\n      return { col: s.col - 1, row: s.row - 1 };\n\n    default:\n      return s;\n  }\n};\n\n// Given any 2 squares on a grid\n// return the top left square of their rectangle\n// ex: given 20 and 02 will return 00 from the square grid below\n// 00, 10, 20\n// 01, 11, 21\n// 02, 12, 22\nexport const topLeft = (s1, s2) => {\n  return {\n    col: Math.min(s1.col, s2.col),\n    row: Math.min(s1.row, s2.row)\n  };\n};\n\n// Given any 2 squares on a grid\n// return the bottom right square of their rectangle\n// ex: given 20 and 02 will return 22 from the square grid below\n// 00, 10, 20\n// 01, 11, 21\n// 02, 12, 22\nexport const bottomRight = (s1, s2) => {\n  return {\n    col: Math.max(s1.col, s2.col),\n    row: Math.max(s1.row, s2.row)\n  };\n};\n\nexport const cellToId = cell => `${cell.col},${cell.row}`;\nexport const pointToId = point => `${point.x},${point.y}`;\n\nexport const idToCell = id => {\n  const coords = id.split(\",\");\n  return { col: parseInt(coords[0], 10), row: parseInt(coords[1], 10) };\n};\n\nexport const idToPoint = id => {\n  const coords = id.split(\",\");\n  return { x: parseInt(coords[0], 10), y: parseInt(coords[1], 10) };\n};\n\n// Given two squares on a grid\n// return a horizontal L->R row from the top left sq of their rectangle\nexport const getRow = (s1, s2) => {\n  const tlsq = topLeft(s1, s2);\n  const brsq = bottomRight(s1, s2);\n  const row = [];\n\n  let col = tlsq.col;\n\n  while (col <= brsq.col) {\n    row.push({ col: col, row: tlsq.row });\n    col = col + 1;\n  }\n\n  return keyBy(row, cellToId);\n};\n\n// Given two squares on a grid\n// return a vertical T->B column from the top left sq of their rectangle\nexport const getColumn = (s1, s2) => {\n  const tlsq = topLeft(s1, s2);\n  const brsq = bottomRight(s1, s2);\n  const column = [];\n\n  let row = tlsq.row;\n\n  while (row <= brsq.row) {\n    column.push({ col: tlsq.col, row });\n    row = row + 1;\n  }\n\n  return keyBy(column, cellToId);\n};\n\n// given two squares on a grid, returns all squares within their rectangle\n// ex: given 10 and 02 will return the bracketed sqaures below\n//   [00], [10],  20\n//   [01], [11],  21\n//   [02], [12],  22\nexport const getAllSquares = (s1, s2) => {\n  const tlsq = topLeft(s1, s2);\n  const brsq = bottomRight(s1, s2);\n\n  let squares = {};\n\n  const column = getColumn(tlsq, brsq);\n\n  each(column, s => (squares = { ...squares, ...getRow(s, brsq) }));\n\n  return keyBy(squares, cellToId);\n};\n\nexport const getAllSquaresFromPoint = (s1, radius) => {\n  const topLeft = { col: s1.col - radius, row: s1.row - radius };\n  const bottomRight = { col: s1.col + radius, row: s1.row + radius };\n  return getAllSquares(topLeft, bottomRight);\n};\n\nexport const getMaxColumn = squares => {\n  return Math.max(...map(squares, s => s.col));\n};\n\nexport const getMinColumn = squares => {\n  return Math.min(...map(squares, s => s.col));\n};\n\nexport const getMaxRow = squares => {\n  return Math.max(...map(squares, s => s.row));\n};\n\nexport const getMinRow = squares => {\n  return Math.min(...map(squares, s => s.row));\n};\n\nexport const getBoundingCorners = squares => ({\n  topLeft: `${getMinColumn(squares)},${getMinRow(squares)}`,\n  topRight: `${getMaxColumn(squares)},${getMinRow(squares)}`,\n  bottomRight: `${getMaxColumn(squares)},${getMaxRow(squares)}`,\n  bottomLeft: `${getMinColumn(squares)},${getMaxRow(squares)}`\n});\n\nexport const getBoundary = ids => {\n  const squares = ids.map(idToCell);\n  const corners = getBoundingCorners(squares);\n  const boundarySquares = [\n    ...Object.keys(\n      getRow(idToCell(corners.topLeft), idToCell(corners.topRight))\n    ),\n    ...Object.keys(\n      getRow(idToCell(corners.bottomLeft), idToCell(corners.bottomRight))\n    ),\n    ...Object.keys(\n      getColumn(idToCell(corners.bottomLeft), idToCell(corners.topLeft))\n    ),\n    ...Object.keys(\n      getColumn(idToCell(corners.bottomRight), idToCell(corners.topRight))\n    )\n  ];\n  return uniq(boundarySquares);\n};\n\nexport const getPoint = (x, y) => ({ x, y });\n\nexport const diagonal_distance = (p0, p1) => {\n  var dx = p1.x - p0.x,\n    dy = p1.y - p0.y;\n  return Math.max(Math.abs(dx), Math.abs(dy));\n};\n\nexport const round_point = p => {\n  return getPoint(Math.round(p.x), Math.round(p.y));\n};\n\nexport const lerp_point = (p0, p1, t) => {\n  return getPoint(lerp(p0.x, p1.x, t), lerp(p0.y, p1.y, t));\n};\n\nexport const lerp = (start, end, t) => {\n  return start + t * (end - start);\n};\n\nexport const line = (p0, p1) => {\n  var points = [];\n  var N = diagonal_distance(p0, p1);\n  for (var step = 0; step <= N; step++) {\n    var t = N === 0 ? 0.0 : step / N;\n    points.push(round_point(lerp_point(p0, p1, t)));\n  }\n  return points;\n};\n","export const TILE_SIZE = 20;\nexport const CELL_WIDTH = TILE_SIZE;\nexport const CELL_HEIGHT = TILE_SIZE;\nexport const COLUMNS = 60;\nexport const ROWS = 40;\nexport const MAP_HEIGHT = CELL_HEIGHT * ROWS;\nexport const MAP_WIDTH = CELL_WIDTH * COLUMNS;\n","import _ from \"lodash\";\n\nimport {\n  // getAllSquares,\n  getBoundary,\n  getCellDistance,\n  getNeighbor,\n  cellToId,\n  idToCell,\n  idToPoint,\n  pointToId,\n  getAllSquaresFromPoint,\n  line\n} from \"./grid/math\";\n\nimport {\n  TILE_SIZE,\n  CELL_WIDTH,\n  CELL_HEIGHT,\n  COLUMNS,\n  ROWS\n  // MAP_HEIGHT,\n  // MAP_WIDTH\n} from \"../constants/game.constants\";\n\nexport const observeBoundaries = id => {\n  const loc = idToCell(id);\n  if (loc.col < 0) return false;\n  if (loc.col >= COLUMNS) return false;\n  if (loc.row < 0) return false;\n  if (loc.row >= ROWS) return false;\n\n  return true;\n};\n\nexport const getInitialCtx = canvasRef => {\n  const ctx = canvasRef.current.getContext(\"2d\");\n  ctx.font = `${TILE_SIZE}px serif`;\n  ctx.textBaseline = \"top\";\n  return ctx;\n};\n\nexport const drawPlayer = (ctx, player) => {\n  ctx.fillStyle = `rgb(50,50,50,1)`;\n  ctx.fillText(\n    \"@\",\n    player.loc.col * CELL_WIDTH,\n    player.loc.row * CELL_HEIGHT,\n    CELL_WIDTH\n  );\n};\n\nexport const drawPlayerHalo = (ctx, player, cellIds, cells) => {\n  const localCells = getAllSquaresFromPoint(player.loc, 8);\n  const localCellIds = Object.keys(localCells);\n  const localBoundaryCellIds = getBoundary(localCellIds);\n  const litCellIds = [];\n\n  // console.log(localBoundaryCellIds);\n\n  localBoundaryCellIds.forEach(id => {\n    const start = { x: player.loc.col, y: player.loc.row };\n    const end = idToPoint(id);\n    const theLine = line(start, end);\n    // console.log({ start, end, theLine, player });\n\n    // iterate over theLine!!\n    _.each(theLine, point => {\n      const cellId = pointToId(point);\n      const cell = cells[cellId];\n\n      if (cell && cell.type && cell.type === \"floor\") {\n        litCellIds.push(cellId);\n      } else if (cell && cell.type && cell.type === \"wall\") {\n        litCellIds.push(cellId);\n        return false;\n      } else {\n        return false;\n      }\n    });\n    // from start if it's floor light\n    // it it's wall bail on all other cells\n    // cells[pointToId()]\n  });\n\n  // console.log({ litCellIds });\n\n  // from player location build halo of cell ids\n  // get distance on all cells in halo\n  // if they are open render light\n  _.uniq(litCellIds).forEach(cellId => {\n    const cell = cells[cellId];\n    if (cell) {\n      const opacity =\n        ((getCellDistance(cellToId(player.loc), cellId) - 8) * -1) / 7;\n      // ctx.fillStyle = `rgb(230,180,59,${opacity})`;\n      ctx.fillStyle = `rgb(255,255,255,${opacity})`;\n      // ctx.fillStyle = `rgb(255,0,0,${opacity})`;\n      ctx.fillRect(\n        cell.col * CELL_WIDTH,\n        cell.row * CELL_HEIGHT,\n        CELL_WIDTH,\n        CELL_HEIGHT\n      );\n\n      if (cell.type === \"wall\") {\n        // ctx.fillStyle = `rgb(60,85,92, ${opacity})`;\n        // ctx.fillStyle = `rgb(135,157,163, ${opacity})`;\n        ctx.fillStyle = `rgb(67, 82, 68, ${opacity})`;\n        // ctx.font = `${TILE_SIZE}px serif`;\n        // ctx.fillText(\"#\", cell.col * CELL_WIDTH, cell.row * CELL_HEIGHT);\n        ctx.fillRect(\n          cell.col * CELL_WIDTH,\n          cell.row * CELL_HEIGHT,\n          CELL_WIDTH,\n          CELL_HEIGHT\n        );\n      }\n    }\n  });\n};\n\n// cellIds ['id', ...]\n// cells { id: {col: 0, row: 0} }\n// player { loc: {col: 0, row: 0} }\n// debug boolean\nexport const drawMap = (ctx, cellIds, cells, player, debug = false) => {\n  cellIds.forEach(cellId => {\n    const cell = cells[cellId];\n\n    ctx.fillStyle = cell.open ? `rgb(10,10,10)` : `rgb(10,10,10)`;\n    // ctx.fillStyle = cell.open ? `rgb(10,10,10)` : `rgb(11,11,11)`;\n    ctx.fillRect(\n      cell.col * CELL_WIDTH,\n      cell.row * CELL_HEIGHT,\n      CELL_WIDTH,\n      CELL_HEIGHT\n    );\n\n    // testing\n    // if (cell.type === \"floor\") {\n    //   ctx.fillStyle = `rgb(255,255,255, 1)`;\n    //   ctx.font = `${TILE_SIZE}px serif`;\n    //   ctx.fillText(\"☐\", cell.col * CELL_WIDTH, cell.row * CELL_HEIGHT);\n    // }\n\n    // if (cell.type === \"wall\") {\n    //   ctx.fillStyle = `rgb(255,255,255, 1)`;\n    //   ctx.font = `${TILE_SIZE}px serif`;\n    //   ctx.fillText(\"#\", cell.col * CELL_WIDTH, cell.row * CELL_HEIGHT);\n    // }\n\n    if (debug) {\n      ctx.fillStyle = `rgb(200,0,0, 1)`;\n      ctx.font = \"8px serif\";\n      ctx.fillText(cellId, cell.col * CELL_WIDTH, cell.row * CELL_HEIGHT);\n    }\n  });\n};\n\nexport const drunkardsWalk = (cellIds, cells, randomStart = false) => {\n  const dig = cell => (cell.open = true);\n  const directions = [\"N\", \"E\", \"S\", \"W\"];\n\n  // Pick start location\n  let current = randomStart\n    ? _.sample(cellIds)\n    : `${Math.ceil(COLUMNS / 2)},${Math.ceil(ROWS / 2)}`;\n\n  dig(cells[current]);\n\n  const digger = () => {\n    // get the next cell Id\n    const nextCellId = cellToId(\n      getNeighbor(cells[current], _.sample(directions))\n    );\n\n    // test that it is in bounds\n    if (observeBoundaries(nextCellId)) {\n      if (!cells[nextCellId].open) {\n        dig(cells[nextCellId]);\n        current = nextCellId;\n      }\n    }\n  };\n\n  _.times(2500, digger);\n};\n\nexport const drunkardsWalk2 = (cellIds, cells, randomStart = false) => {\n  const dig = cell => (cell.open = true);\n  const directions = [\"N\", \"E\", \"S\", \"W\"];\n\n  // Pick start location\n  let current = randomStart\n    ? _.sample(cellIds)\n    : `${Math.ceil(COLUMNS / 2)},${Math.ceil(ROWS / 2)}`;\n\n  dig(cells[current]);\n\n  const digger = () => {\n    // get the next cell Id\n    const nextCellId = cellToId(\n      getNeighbor(cells[current], _.sample(directions))\n    );\n\n    // test that it is in bounds\n    if (observeBoundaries(nextCellId)) {\n      dig(cells[nextCellId]);\n      current = nextCellId;\n    }\n  };\n\n  _.times(1500, digger);\n};\n\nexport const isWall = (CELLS, cellId) => {\n  const point = idToPoint(cellId);\n  const neighbors = [\n    `${point.x},${point.y - 1}`, // N\n    `${point.x + 1},${point.y}`, // E\n    `${point.x},${point.y + 1}`, // S\n    `${point.x - 1},${point.y}` // W\n  ];\n\n  const floors = [];\n  neighbors.forEach(id => {\n    const cell = CELLS[id];\n    if (cell && cell.type === \"floor\") {\n      floors.push(id);\n    }\n  });\n\n  if (floors.length > 0) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const categorizeCells = (CELL_IDS, CELLS) => {\n  const FLOOR_CELL_IDS = [];\n  const WALL_CELL_IDS = [];\n  const ROCK_CELL_IDS = [];\n\n  // mark floors\n  CELL_IDS.forEach(id => {\n    const cell = CELLS[id];\n    if (cell.open) {\n      cell.type = \"floor\";\n      FLOOR_CELL_IDS.push(id);\n      return;\n    }\n  });\n\n  CELL_IDS.forEach(id => {\n    const cell = CELLS[id];\n    if (!cell.type && isWall(CELLS, id)) {\n      // console.log(\"WALL!\");\n      cell.type = \"wall\";\n      WALL_CELL_IDS.push(id);\n      return;\n    }\n  });\n};\n","import React, { useEffect, useRef, useState } from \"react\";\nimport useEventListener from \"@use-it/event-listener\";\nimport { cellToId, getAllSquares, getNeighbor } from \"./lib/grid/math\";\nimport { observeBoundaries, drawPlayerHalo } from \"./lib/canvas\";\nimport _ from \"lodash\";\n\nimport \"./App.css\";\n\nimport {\n  COLUMNS,\n  ROWS,\n  MAP_HEIGHT,\n  MAP_WIDTH\n} from \"./constants/game.constants\";\n\nimport {\n  drawMap,\n  drawPlayer,\n  getInitialCtx,\n  drunkardsWalk,\n  drunkardsWalk2,\n  categorizeCells\n} from \"./lib/canvas\";\n\nlet CELLS = getAllSquares(\n  { col: 0, row: 0, open: false },\n  { col: COLUMNS, row: ROWS }\n);\nconst CELL_IDS = Object.keys(CELLS);\n\ndrunkardsWalk2(CELL_IDS, CELLS);\ncategorizeCells(CELL_IDS, CELLS);\n\nlet PLAYER = {\n  loc: _.find(CELLS, cell => cell.open)\n};\n\nlet ctx;\n\nconst renderGame = ctx => {\n  ctx.clearRect(0, 0, MAP_WIDTH, MAP_HEIGHT);\n  drawMap(ctx, CELL_IDS, CELLS, PLAYER);\n  drawPlayerHalo(ctx, PLAYER, CELL_IDS, CELLS);\n  drawPlayer(ctx, PLAYER);\n};\n\nexport default function App() {\n  const canvasRef = useRef(null);\n  const [settings, setSettings] = useState({\n    algorithm: \"dw\",\n    iterations: 30,\n    startingLocation: \"30,20\",\n    randomStartingLocation: \"on\"\n  });\n\n  const rebuild = () => {\n    CELLS = getAllSquares(\n      { col: 0, row: 0, open: false },\n      { col: COLUMNS, row: ROWS }\n    );\n\n    const algorithms = {\n      dw: drunkardsWalk,\n      dw2: drunkardsWalk2\n    };\n\n    _.times(settings.iterations, () =>\n      algorithms[settings.algorithm](\n        CELL_IDS,\n        CELLS,\n        settings.randomStartingLocation === \"on\"\n      )\n    );\n\n    categorizeCells(CELL_IDS, CELLS);\n\n    PLAYER = {\n      loc: _.find(CELLS, cell => cell.open)\n    };\n\n    renderGame(ctx);\n  };\n\n  const handleSettingChange = (path, value) => {\n    const newSettings = { ...settings };\n    newSettings[path] = value;\n    setSettings(newSettings);\n  };\n\n  useEffect(() => {\n    ctx = getInitialCtx(canvasRef);\n    renderGame(ctx);\n  });\n\n  const movePlayer = dir => {\n    const newLoc = getNeighbor(PLAYER.loc, dir);\n    const newLocId = cellToId(newLoc);\n    if (!observeBoundaries(newLocId)) return;\n    if (!CELLS[newLocId].open) return;\n\n    PLAYER.loc = newLoc;\n\n    renderGame(ctx);\n  };\n\n  const handleKeyDown = ({ key }) => {\n    // key bindings\n    const PLAYER_MOVE_N = [\"ArrowUp\", \"8\", \"w\"];\n    const PLAYER_MOVE_E = [\"ArrowRight\", \"6\", \"d\"];\n    const PLAYER_MOVE_S = [\"ArrowDown\", \"2\", \"s\"];\n    const PLAYER_MOVE_W = [\"ArrowLeft\", \"4\", \"a\"];\n\n    if (PLAYER_MOVE_N.includes(String(key))) {\n      movePlayer(\"N\");\n    }\n\n    if (PLAYER_MOVE_E.includes(String(key))) {\n      movePlayer(\"E\");\n    }\n\n    if (PLAYER_MOVE_S.includes(String(key))) {\n      movePlayer(\"S\");\n    }\n\n    if (PLAYER_MOVE_W.includes(String(key))) {\n      movePlayer(\"W\");\n    }\n  };\n\n  useEventListener(\"keydown\", handleKeyDown);\n\n  return (\n    <div className=\"App\">\n      <div className=\"settings\">\n        SETTINGS:\n        <label htmlFor=\"Algorithm\">Algorithm:</label>\n        <select\n          name=\"Algorithm\"\n          value={settings.algorithm}\n          onChange={e => {\n            handleSettingChange(\"algorithm\", e.target.value);\n          }}\n        >\n          <option value=\"dw\">Drunkards Walk</option>\n          <option value=\"dw2\">Drunkards Walk 2</option>\n        </select>\n        <label htmlFor=\"iterations\">Iterations:</label>\n        <input\n          name=\"iterations\"\n          type=\"number\"\n          min=\"1\"\n          max=\"1000\"\n          value={settings.iterations}\n          onChange={e => {\n            handleSettingChange(\"iterations\", e.target.value);\n          }}\n        />\n        {/* <label htmlFor=\"startLocation\">Starting Location:</label>\n        <input\n          type=\"text\"\n          name=\"startLocation\"\n          value={settings.startingLocation}\n          onChange={e => {\n            handleSettingChange(\"startingLocation\", e.target.value);\n          }}\n        /> */}\n        <label htmlFor=\"randomStart\">Random Starting Location</label>\n        <input\n          type=\"checkbox\"\n          name=\"randomStart\"\n          checked={settings.randomStartingLocation}\n          onChange={e => {\n            handleSettingChange(\n              \"randomStartingLocation\",\n              settings.randomStartingLocation === \"on\" ? \"\" : \"on\"\n            );\n          }}\n        />\n        <button onClick={rebuild}>Rebuild Map</button>\n      </div>\n      <canvas\n        width={MAP_WIDTH}\n        height={MAP_HEIGHT}\n        className=\"canvas\"\n        ref={canvasRef}\n      />\n    </div>\n  );\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}